各スレッドで必要があれば生成され、キャッシュされる
* もとのemittableが存在している限り、再度作られることはない
元となったemittableとライフサイクルが一緒








問題：
luajit VM levelで、１つのコネクションをacceptするのは１つのスレッドだけであるが、コネクションからのデータの呼び出し（およびパース）は
そのスレッドと別のスレッドが行うことがある。現状の実装だと、requestを受信した場合は受信したスレッドがfiberを生成して実行を行うことになっていたが、
受信したスレッドはコネクションをacceptしていないため、コネクションに対応するnamespaceが設定されていないため関数の実行が行えない。
(listnerは存在するため関数自体は読み込まれてはいる）どのようにこのケースでも正常にfiberを実行させるか。

解決案：
*1 コネクションのオーナーとなるthreadをコネクションオブジェクトに記録しておいて、受信したスレッドがオーナーでなければオーナーへdelegateする
*2 acceptしたスレッドでない場合、なんとかlistnerのnamespaceから呼び出すべき関数を引っ張ってきて実行させる。
*3 acceptしたスレッドが他のスレッドにもacceptさせた状態にすることで、どのスレッドにおいても問題のコネクションをacceptした状態にする。

objectへのアクセスを真にシーケンシャルにしたいのであれば*1
*2は処理が特殊化するため、さけたい（しかも結局luajit上のオブジェクトは欲しい)
acceptしたスレッドでない場合、あらためてacceptするか？->何回も__openなどが呼ばれてしまうのは嫌だ
*3でもいいが、delegate含めタイミングでのバグが多くなりそう。

*1かなあ
しかし強一貫性が必要なくて並列度をあげたいケースがあるだろうからできればdelegate必須にはしたくない



a -> b -> c -> d execute a => b -> c -> d -> a
a -> b -> c -> d execute b => a -> c -> d -> b
a -> b -> c -> d execute c => a -> b -> d -> c
a -> b -> c -> d execute d => a -> b -> c -> d

1, remove entry
2, append it to last



class linkedqueue<T> {)
    struct element {
        volatile struct element *m_next;
        T m_data;
        element(T &data) : m_next(NULL), m_data(data) {}
    }
    static struct element m_sentinel;
    thread_local array<element> m_pool;
    volatile struct element *m_top, *m_tail;
    volatile U32 m_version;
    linkedqueue() : m_top(&m_sentinel), m_tail(&m_sentinel) {}
    T *push(T &data) {
        element *e = m_pool.alloc(data);
        while (true) {
            element *tail = m_tail, *next = tail->m_next;
            if (next) {
                cas(&m_tail, tail, next);
            }
            else {
                if (cas(&(tail->m_next), NULL, e)) {
                    cas(&m_tail, m_tail, e);
                    return e->m_data;
                }
            }
        }
    }
    
    T *pop() {
        while (true) {
            element *top = m_top->m_next;
            if (top) {
                element *next = top->m_next, *nn = NULL;
                if (next) { nn = next->m_next; }
                if (cas(&(top->m_next), next, nn)) {
                    return next;
                }
            }
            return NULL;
        }
    }
    
    T *clear() {
        //m_top->m_next => NULL
        //m_tail => m_sentinel
        return cas(&m_top, m_top, &m_sentinel);
    }
    
    
}


fiber::wait(emittable *e, event_id id, UINT32 t_o) {
    fiber::watcher *w = new_watcher();
    w->m_msgid = serializer::new_id();
    return fabric::suspend(
}




listener (server socket)
__open		:	新しい接続を受け付けた(protocol level) listenerのon_readで受け付けられた接続に対して、handshakeが完了した後呼ばれる。
					サーバー側は、クライアントへのrpcはこの時点から可能なのでパスワードとアカウントの入力を求めたりしてアプリケーションレベルでのestablishのための処理を開始する
__accept	:	クライアントからのrpcを受け付けてよい状態になった。認証トライアルが完了したということ。server socketに対して__grantが呼ばれた。
					このために必ずサーバーはクライアントに対して何らかのrpcを呼び出して、socket:__grantを呼びださないといけないが名前が考えもの。
__close		: 	接続が閉じた(protocol level)
__data			:	データを受信した。raw socketだけ。

socket (clietn socket)
__open		:	新しい接続を受け付けた(protocol level) openしたsocketにたいして、handshakeが完了した後呼ばれる。
__accept	:	サーバーに対してrpcを実行できる状態になった。
					accepted__というbuild-inの関数が呼び出され、その中で__grantが呼ばれた後この関数が呼ばれる。
					サーバーをテストすることが可能。
__close		: 	接続が閉じた(protocol level)
__data			:	データを受信した。raw socketだけ。

timer
__tick			: 	tick event が発動した

signal
__signal		:	signal handlerが呼び出された

thread
__end			:  スレッドが終了した

fs
__****			:  あとで。いろんなイベント











yue.core.open
yue.core.connect
yue.core.listen
yue.core.timer
yue.core.signal







c = yue.core.open("hoge://huga");
c.__accepted = function ()
end 
c.__closed = function ()
end

e = c.anyfunc(a, b, c, d)

















endpoint => (stream_endpoint, datagram_endpoint, loop_endpoint)  invoker->respond(serializer, object)


fiber {
	int respond(serializer, data) {
		invoker->respond(serializer, data)
	}
	
	int resume(type, object) {
		if (this->owner() != fiber::current_thread()) {
			this->delegate(this->owner(), object);
			return;
		}
		switch(coroutine->resume(object)) {
		yield:		return;
		finish:		this->respond(serializer, coroutine);
		error:		this->respond(serializer, coroutine);
		}
	}
}

accept : 
fabric::tlf()->create()->resume(type_accept, { parent_fd, accepted_fd });

read : 
fabric::tlf()->create()->resume(type_read, { parent_fd, read_fd });	

proc : 
fabric::tlf()->create()->resume(type_proc, { parent_fd, object }); //only this returns response

open : 
fabric::tlf()->create()->resume(type_open, opened_fd)

close : 
fabric::tlf()->create()->resume(type_close, closed_fd)

timer : 
fabric::tlf()->create()->resume(type_timer, timer_id);

signal : 
fabric::tlf()->create()->resume(type_signal, signal_no);







__peer().control_jquery("#disapper", "hide")




yue.core.listen('ws://0.0.0.0:8888/chat')
yue.core.open('ws://10.0.0.1:8888/chat')


released files

yue			: the yue server
yue.so 		: core C++ library to access yue
yuec.lua	: core lua library to access yue (built on yue.so)
					access yue from luajit console
					running yue as master, slave
wsynth.lua	: library build on yuel.lua, which implements scalable complex system on IaaS.


yue module

yue.core		-- basic feature
yue.core.poll
yue.core.connect
yue.core.listen
yue.core.timer
yue.core.stop_timer
yue.core.die
yue.core.try
yue.core.open

yue.dev			-- features to develop library integrate with yue
yue.dev.read
yue.dev.write
yue.dev.yield

yue.client 	-- modules to access yue from luajit console (or client program)
yue.client.run
yue.client.exec
yue.client.mode

yue.master		-- features related master node 
yue.master.connections

yue.uuid
yue.uuid.new

yue.hspace
yue.hspace.__newindex


yue.util
yue.util.time.now
yue.util.time.clock





yue.open('http://www.foo.com').controller.action({k1 = v1, k2 = v2, k3 = v3})
 => http://www.foo.com/controller/action?k1=v1&k2=v2&k3=v3




local t = yue.timer(1.0f, function () 
end)






local c = yue.connect('udp://multicast:9999')

try(function() 
		c.find_node():timed_callback(5.0f, function(ok,r)
			if ok then
				yue.master_conns.insert(yue.open(r))
				if #yue.master_conns < 3 then
					self.finish()
				end
			else if r[1] == yue.NBR_ETIMEOUT then
				print('cannot find enough number of master node')
				error(e)
			end
		end
	end,
	function(e) -- catch
		print('cannot find enough number of master node', e)
		return false
	end,
	function() -- finally
	end
)




yue.run(function ()
	yue.try(function () 
	
	end)
	:catch(function ()
	
	end)
	:finally(function ()
	
	end)
end)
















require 'bignum'

bn = bignum.new("123456789123456789123456789")

assert(bn == yue.connect('tcp://localhost:8888').send_bignum(bn))

-- bignum.lua --







require 'yue'

function test()
	local c = yue.open('tcp://localhost:8888')
	for v = 0, 1000, 1 do
		local sent_time = c.keepalive(yue.now())
		local elapsed = (yue.now() - sent_time);
	end
end

function init()
	for v = 0, 1000, 1 do
		test()
	end
end

function yue.open(addr)
	local c = yue.connect(addr)
	local omt = c.getmetatable()
	local mt = {
		__index = function (obj, key) 
			return obj[key] if obj[key]
			local r = {
				co = coroutine.create(function (...) 
					return omt.__index[key](...)
				end)
			}
			local comt = {
				__call = function (callee, ...)
					return coroutine.resume(callee.co, ...)
				end
			}
			r.setmetatable(comt)
			return r
		end, 
		__newindex = omt.__newindex
	}
	c.setmetatable(mt)
	return c
end













-------------------------------------------------------

struct session_pool {
	array<session> m_ss;
	int init(net *s, int max_hint);
	void fin();
	
	int connect(const char *addr, handler h) {
		session *s = m_ss.alloc();
		if (!s) { return INVALID_MSGID; }
		return s->connect(addr, h);
	}
};

struct session_mesh {
	map<session, const char *> m_ss;
	int init(net *s, int max_hint);
	void fin();
	
	int connect(const char *addr, handler h) {
		session *s = m_ss.alloc(addr);
		if (!s) { return INVALID_MSGID; }
		return s->connect(addr, h);
	}
};

fiber *f; fabric fbr;
session_pool sp;
MSGID msgid = sp.connect(addr, f);
fabric::yield(f, msgid);

template <>
inline int procedure<callproc::rval, callproc::args>
	::operator () (remote_session r) {
	fabric &fbr = fabric::tlf();
	serializer &sr = fbr.sr();
	verify_success(sr.pack_response(res, fiber::obj().msgid()));
	if (r < 0) {
		fiber::respond(fbr.packer(),
			fbr.set_last_error(NBR_ECONNECT, fiber::obj().msgid(), c_nil()));
		fiber::fin();
		return NBR_OK;
	}
	return invoke(fbr, fiber::obj());
}

struct session_mesh {
	
};









static int lua::connection::index(VM vm) {
}
static int lua::connection::newindex(VM vm) {
}

static int lua::method::call(VM vm) {
	method *m = reinterpret_cast<method *>(lua_touserdata(vm, -2));
	lua_error_check(vm, m, "invalid meta-method call\n"); 
	if (m->m_conn.m_ra.valid()) {
		coroutine *co = to_co(vm);
		lua_error_check(vm, co, "not call from coroutine\n");
		PROCEDURE(callproc)::args a(co);
		msgid = PROCEDURE(callproc)::call(m->m_conn.m_ra, a);
		lua_error_check(vm, msgid != INVALID_MSGID, "fail to send command\n")
		lua_error_check(vm, ll().attached()->yield(fb(), msgid) >= 0, "fail to yield\n");
		lua_error_check(vm, co->yield() >= 0, "fail to lua_yield\n");
	}
	else {
		MSGID msgid = serializer::new_id();
		lua_error_check(vm, ll().attached()->yield(fb(), msgid) >= 0, "fail to yield\n");
		lua_error_check(vm, ll().attached()->mesh().connect(m->m_conn.m_host, watcher(msgid)) >= 0, "fail to connect\n");
		return NBR_OK;
	}
}

template <>
int procedure<callproc::rval, callproc::args>
	::operator () (remote_actor &ra, int r) {
	fabric &fbr = fabric::tlf();
	if (r < 0) {
		msgid = m_connmgr.connect(m->m_conn.m_host);
		if (msgid != INVALID_MSGID) {
			fiber::respond(fbr.packer(),
			fbr.set_last_error(NBR_ECONNECT, fiber::obj().msgid(), "reconnection fails"));
			return NBR_OK;
		}
		if (fbr.yield(this, msgid) != fiber::exec_yield) {
			fiber::respond(fbr.packer(),
			fbr.set_last_error(NBR_EEXPIRE, fiber::obj().msgid(), "reconnection fails"));
			return NBR_OK;
		}
	}
}


rpc_mt = {
	__call : function (self, ...) {
		return self.actor.rpc(self.uuid, self.k, ...)
	}
}

method_mt = {
	__index : function (obj, key)
		local v = obj[key]
		if v then return v
		v = {
			uuid : obj.__uuid
			k : key,
			actor : yue.hspace.from(obj.__uuid)
		}
		setmetatable(v, rpc_mt)
		obj[key] = v
		return v;
	end
}


function yue:bless(class)
	if _G[class] then 
		return _G[class]
	end
	local c = {}
	local mt = {
		__index = function (t, k) 
			return c[k]
		end
	}
	c.new = function (...)
		local v = {
			__uuid : obj.__uuid
		}
		if yue.hspace.from(v.uuid) == yue.current then
			setmetatable(v, mt)
		else
			setmetatable(v, method_mt)
		end
		v:initialize(...)
		return v
	end
	_G[class] = c
	return c
end

yue.bless("Player")
function Player:initialize(name, conn)
	self.conn = conn
	self.name = name
	self.male = self:select_sex()
	self.birthday = self:select_birthday()
end
function Player:select_sex()
	return self.conn.select_sex()
end
function Player:select_birthday()
	return self.conn.select_birthday()
end
function Player:attack(target)
	if self.male then
		target.caught_damage(rand() % 100)
	else
		target.caught_damage(rand() % 50)
	end
end


obj.func => 'method' if obj.func is originally nil otherwise correspond object.
obj.func2 = obj.func obj.func2 is 'method'
function testfunc(obj) => if testfunc is called from rpc, what should be returned to caller?
	return obj.func
end

client:
obj.func(obj) => ???

server:
function func(o)
	return o.func2 nil or correspond object if blessed. 'method' or correspond object otherwise.
end

y['tcp://10.0.0.1:8888/']
y['tcp://10.0.0.2:8888/']
y['tcp://10.0.0.3:8888/']
y[0]	0th worker
y[1]	1th worker
...
y[N]	Nth worker




struct connection {
	remote_actor m_conn;
}; /* has connection_index */
struct method {
	connection *c;
	char name[256];
} /* has method_call */;


//yue lua scripting overview


client:
y = require('yue')
c = y.connect('tcp://localhost:8888') # c is empty table with metatable
printf(c.f(100, 200, 300)) # 600


p = y.connect('tcp://localhost:8888').login('iyatomi', 'koei1000', 'Player')
p:move_to(10, 20, 30)
p:get_hp() # 6

function client_choose_birth_place()
	return ListBox.new('tokyo', 'kanagawa', 'saga').open()
end


server:
y = require('yue')

function f(a1, a2, a3)
	return a1 + a2 + a3;
end

Player = {}
y.bless(Player)
function Player.new()
	p = {}
	p.hp = 6
	p.x,p.y,p.z = g_start_pos[client_choose_birth_place()];
	return p;
end
function Player:move_to(dx, dy, dz)
	self.x += dx
	self.y += dy
	self.z += dz
end
function Player:get_hp()
	return self.hp
end


//fiber joint (mesh)

namespace yue {
namespace util {
namespace mesh {
template <class PTPL, class ATPL>
struct parallel {
	int operator () (fabric &, object &o) {
	}
};




template <class TPL>
struct step {

};

template <class TPL>
struct cycle {
};

}
}

}

typedef util::mesh::parallel<util::tuple<keepalive, keepalive, keepalive> > k3;
keepalive::args a1, a2, a3;
a1.m_tstamp = a2.m_tstamp = a3.m_tstamp = util::time::now();

util::tuple<remote_actor, remote_actor, local_actor> actor(ra, ra2, la);
k3::args args(a1, a2, a3);

k3::call(actor, arg);

PROCEDURE(three_keepalive)::args a;
PROCEDURE(three_keepalive)::call(ra, a);






//how to map serialize object and struct

struct A {
	float 	m_a1;
	U32		m_a2;
	char	*m_a3;
	float a1();
	U32 a2();
	char *a3();
	
	int pack(serializer &sr) {
		sr << m_a1;
		sr << m_a2;
		sr << m_a3;
		return sr.len();
	}
};

=> 

A a;
a.pack(sr);

pbuf pbf;
memcpy(pbf.p(), sr.p(), min(pbf.len(), sr.len()));

object o;
sr.unpack(o, pbf, o.sbf());

o.arg(0) => type:float, value:m_a1
o.arg(1) => type:U32, value:m_a2
o.arg(2) => type:char*, value:m_a3

struct A_wrapper {
	union {
		A *a;
		object o_A;
	};
	int type;
	
	A_wrapper(A *ta) : type(local), a(ta) {}
	A_wrapper(object &o)  : type(remote), o_A(o) {}
	
	float a1() { 
		switch(type) {
			remote: return o_A.arg(0);
			local: return a->a1();
		}
	}
	U32 a2() { 
		switch(type) {
			remote: return o_A.arg(1);
			local: return a->a2();
		}
	}
	char *a3() { 
		switch(type) {
			remote: return o_A.arg(2);
			local: return a->a3();
		}
	}
};

struct struct_command1 {
	float m_a1;
	U32 m_a2;
	char *m_a3;

	U8 cmd() { return rpc::proc::command1; }
};


template <class SOURCE>
struct command1 {
	SOURCE src;
	float	a1();
	U32	a2();
	char	*a3();
};

template<>
command1::a1<object>() {
	return src.arg(0);
}
template<>
command1::a1<struct_command1>() {
	return m_a1;
}

procedure<remote_actor, object>
procedure<local_actor, struct_command1>

template <class 


