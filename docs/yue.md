yue: brand-new server frame work for real time statefull network application with complex system
==================================================================================================

# Motivation
## プロジェクトを始めた理由と達成したいこと
- #### 革新的な仕様を実装したMMOの開発があまり行われなくなったことはMMOというゲームのジャンルが発展していく際の大きな問題だと感じていた
- #### 革新的な仕様を中心にして実装した場合、失敗した時のリスクが大きいことがそういった開発が行われなくなった理由
- #### リスクが大きいのはMMOの開発の難度が高いこと、開始するために大きな初期投資が必要なこと
- #### MMOの開発の難度を下げ、small startを可能にすることで革新的なMMOが再び登場するようにしたい
## yueはそのためのサーバーフレームワーク
- #### 技術的にはMMOの開発だけでなくいろいろな応用の可能性があると考えている（後述）

# yueは何を解決するのか
- ## 開発の難しさ。主に２つ
#### 常時接続であることによるクライアントの状態管理
#### サーバー側の分散処理
- ## small startを可能にするのは?

# yueは何を解決するのか
- ## 開発の難しさ。主に２つ
#### 常時接続であることによるクライアントの状態管理
#### サーバー側の分散処理
- ## small startを可能にするのは?
#### => yueの上に構築されるフレームワークによって解決される(未実装)

# どうやって解決するのか
## RPC
- ## 超使いやすいRPCフレームワークを提供することでネットワークプログラミングを徹底的に楽にする
#### SPLAYという研究（科学計算の開発効率を上げるためのluaのフレームワーク）

# デモ1
## 大事なところ
- ## IDL free
#### 呼び出し可能な関数は動的に簡単に指定できる
- ## handshake free
#### connectなど呼ぶ必要がない（RPCを開始する時に自動的に接続する）

# デモ2
## 大事なところ
- ## fully customizable handshake protocol
#### 接続の状態管理をコールバックで行うことができる
#### コールバックの中でserver -> clientのRPCを行うことで簡単にクライアント・サーバーのhandshakeプロトコルを実装できる
- ## handshake independent rpc execution
#### RPCの実行はhandshakeが終わるまで自動的に待つ
#### 一旦接続が切れても、自動的にネットワークアクセスのコードのところで実行が止まり、再接続後そこから開始できる

# デモ3
## 大事なところ
- ## rpc procedure name convention
#### RPCで呼ばれる関数名に規約があり、呼び出し毎に柔軟に挙動を変えることができる
- ## concept of "RPC Peer"
#### RPCを呼び出した実態へのリンク(yue.peer())を使うことで、RPCの実行中に呼び出し側から呼び出し元へRPCすることができる
#### RPCの処理中に追加の情報を呼び出し側に問い合わせたくなった場合（キャラメイキングとか）などに直感的に処理を記述できる

# デモ４
- ## 大事なところ
- ## multi-node cooperative programming
#### インポートしたライブラリのAPIを呼び出すような気軽さでサーバー間の連携を行える
- ## debugg-ability with "thread RPC"
#### ワーカスレッドに対してもほぼ同様の構文で実行できることに注目
#### 複数スレッドをローカルで立ち上げれば、簡単に分散処理環境をエミュレート出来る 

# 技術的に何をやっているのか
- ## スクリプト側はLuaJIT
- ## C/C++で書かれたマルチスレッドサーバーで各スレッドがLuaJITのVMおよびイベントループを持っている
- ## ネイティブ部分を含めて全面的にfiber(cooperative thread)ベースのアーキテクチャ
- ## スレッド間はロックフリーなキューを通じてメッセージング。パフォーマンス及びバグりにくさ
- ## msgpackによるストリーム通信で複数のRPCのリクエスト、レスポンスを一度にsend,recvしてスループットを向上させる
- ## 独自のWebsocket実装。下位互換性や使われない仕様をサポートせずに高速に動作

# LuaJIT?
## v8と同等かそれ以上に高速なluaのJITコンパイル処理系
- ## ffiが極めて重要
#### C libraryを直接解釈し呼び出すことでbinding不要かつ高速にFFIを呼び出す仕組み
#### サーバーでGPUを使う時代が来た場合ほとんどの言語と比べて圧倒的なアドバンテージ

# 今後の実装予定
## yue.nalloc
- ## yue.nalloc('10.0.0.1', 'kvs.lua')のような
#### 通常、サーバープログラムにおいて複数サーバーを連携させる場合、予めインフラとして必要な種類のサーバーを用意して利用する
#### yueを使うとサーバー間の連携が圧倒的に容易なため、mallocでメモリを割り当てるように、逆にプログラムから必要なサーバーを作って利用するというアイデア
#### 上記の例で言えば、KVSをプログラムから利用したい場合、開いているサーバーにkvs.luaというプログラムを動かすyueサーバーをたちあげてそこへのコネクションを(yue.openを使って）取得して、RPC経由で開いているサーバーをリソースとして利用するということ。

# 今後の実装予定
## yue.nalloc
- ## もっと言うとawsやrightscaleのAPIで仮想マシンを作ってしまえばアドレスを前もって知る必要もないかも
- ## yue.nalloc(rightscale.new_node().address, 'kvs.lua')みたいな
- ## awsとかの使い方が全く変わってくる可能性が

# 今後の実装予定
## luaによるクライアントフレームワークへのintegration
- ## Corona SDK
- ## Moai SDK
- ## Shiva 3D
#### 基本的にRPCを呼び出す部分を作成すればいいので工数はあまり大きくない

# 今後の実装予定
## world synthesizer
- ## yueをベースにしたCORBAのようなもの
#### データを保持しつつRPCで任意のプログラムを実行してkvs内部でデータを更新できる
#### GPUと連携した複雑なデータの更新(物理演算のような）

# MMOを超えて
- ## 現在のビッグデータの処理は計算的には極めて単純（個数のカウント、検索）
- ## たとえばセンサーからのデータでリアルタイム性の高い物理シミュレーションによる予測などは比べ物にならないほど複雑な処理
- ## おそらく将来GPUと連携する必要があるビッグデータの処理が現れる
- ## その用途にはyueはかなり有望なはず